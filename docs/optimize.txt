def optimize(request):
    id_phase = request.GET.get('id_phase')
    if not id_phase:
        return JsonResponse({"error": "id_phase parameter is missing"}, status=400)
    logger.info(f"ID de phase reçu : {id_phase}")

    try:
        contraintes = PhaseDeveloppement.objects.get(id=id_phase)

        #
        #   convertion des contraintes en dataFrame
        #

        phase = contraintes

        # Initialiser les dictionnaires pour min et max
        min_dict = {}
        max_dict = {}

        # Remplir les dictionnaires avec les valeurs des contraintes
        min_dict = {
            'proteineBrute': phase.proteineBruteMin,
            'energieMetabolisable': phase.energieMetabolisableMin,
            'matiereGrasse': phase.matiereGrasseMin,
            'calcium': phase.calciumMin,
            'phosphore': phase.phosphoreMin,
            'lysine': phase.lysineMin,
            'methionine': phase.methionineMin,
            'cysteineMethionine': phase.cysteineMethionineMin,
            'sodium': phase.sodiumMin,
        }

        max_dict = {
            'proteineBrute': phase.proteineBruteMax,
            'energieMetabolisable': phase.energieMetabolisableMax,
            'matiereGrasse': phase.matiereGrasseMax,
            'calcium': phase.calciumMax,
            'phosphore': phase.phosphoreMax,
            'lysine': phase.lysineMax,
            'methionine': phase.methionineMax,
            'cysteineMethionine': phase.cysteineMethionineMax,
            'sodium': phase.sodiumMax,
        }

        # Convertir les dictionnaires en DataFrames
        min_df = pd.DataFrame(min_dict, index=['min'])
        max_df = pd.DataFrame(max_dict, index=['max'])

        # Concaténer les deux DataFrames
        contraintes_df = pd.concat([min_df, max_df])

        # Initialiser les dictionnaires pour min et max pour les ratios
        min_ratio_dict = {}
        max_ratio_dict = {}

        # Remplir les dictionnaires avec les valeurs des contraintes
        min_ratio_dict = {
            'ratioEnergieProteine': phase.ratioEnergieProteineMin,
            'ratioCalciumPhosphore': phase.ratioCalciumPhosphoreMin,
            'ratioLysineMethionine': phase.ratioLysineMethionineMin
        }

        max_ratio_dict = {
            'ratioEnergieProteine': phase.ratioEnergieProteineMax,
            'ratioCalciumPhosphore': phase.ratioCalciumPhosphoreMax,
            'ratioLysineMethionine': phase.ratioLysineMethionineMax
        }

        # Convertir les dictionnaires en DataFrames
        min_ratio_df = pd.DataFrame(min_ratio_dict, index=['min'])
        max_ratio_df = pd.DataFrame(max_ratio_dict, index=['max'])

        # Concaténer les deux DataFrames
        contraintes_ratio_df = pd.concat([min_ratio_df, max_ratio_df])

        # Ajouter des instructions d'impression et de journalisation après avoir obtenu les contraintes
        print(f"Contraintes obtenues : {contraintes_df}")
        print(f"Contraintes_ratio obtenues : {contraintes_ratio_df}")
        logger.info(f"Contraintes obtenues : {contraintes}")

        code_pays = request.GET.get('code_pays')
        if not code_pays:
            return JsonResponse({"error": "code_pays parameter is missing"}, status=400)
        logger.info(f"Code pays reçu : {code_pays}")
    except PhaseDeveloppement.DoesNotExist:
        logger.error("La tranche d'age spécifiée n'existe pas.")
        raise Http404("La tranche d'age spécifiée n'existe pas.")
    except Exception as e:
        print(f"Erreur lors de la récupération des contraintes : {e}")
        logger.error(f"Erreur lors de la récupération des contraintes : {e}")
        raise Http404("Une erreur s'est produite lors de la récupération de la phase de developpement et ses "
                      "contraintes.")

    try:
        ing_pays = Ingredient.objects.filter(codePays__codePays=code_pays)
        ingredients = []
        for ing in ing_pays:
            ingredient_dict = {
                'nomIngredient': ing.codeIngredient.nomIngredient,
                'proteineBrute': ing.codeIngredient.proteineBrute,
                'energieMetabolisable': ing.codeIngredient.energieMetabolisable,
                'matiereGrasse': ing.codeIngredient.matiereGrasse,
                'celluloseBrute': ing.codeIngredient.celluloseBrute,
                'calcium': ing.codeIngredient.calcium,
                'phosphore': ing.codeIngredient.phosphore,
                'lysine': ing.codeIngredient.lysine,
                'methionine': ing.codeIngredient.methionine,
                'cysteineMethionine': ing.codeIngredient.cysteineMethionine,
                'sodium': ing.codeIngredient.sodium,
                'prix': ing.codeIngredient.prix
            }
            ingredients.append(ingredient_dict)

        # Convertir la liste de dictionnaires en DataFrame
        data_df = pd.DataFrame(ingredients)
        data_df.set_index('nomIngredient', inplace=True)

        # liste des ingredients
        ingredient_list = data_df.index.tolist()

        # extrire le prix de chaque ingredient
        prix = data_df['prix']

        # enlever la colonne du prix
        ingredients_df = data_df.drop("prix", axis=1)

        print(f"liste_data: {data_df}")
        print(f" {prix}")
    except Ingredient.DoesNotExist:
        logger.error("Le pays spécifié n'existe pas ou n'a pas d'ingrédients associés.")
        raise Http404("Le pays spécifié n'existe pas ou n'a pas d'ingrédients associés.")
    except Exception as e:
        logger.error(f"Une erreur s'est produite lors de la récupération des ingrédients : {e}")
        raise Http404("Une erreur s'est produite lors de la récupération des ingrédients.")

    try:
        n = len(ingredients_df)
        X0 = np.array([1] * n)

        df = data_df

        def objectif(X):
            return (np.sum(X * df["prix"]))

        def cons_Prot_inf(X):
            return np.sum(X * df["proteineBrute"]) - contraintes_df.loc["min", "proteineBrute"]

        def cons_Prot_sup(X):
            return contraintes_df.loc["max", "proteineBrute"] - np.sum(X * df["proteineBrute"])

        def cons_EM_inf(X):
            return np.sum(X * df["energieMetabolisable"]) - contraintes_df.loc["min", "energieMetabolisable"]

        def cons_EM_sup(X):
            return contraintes_df.loc["max", "energieMetabolisable"] - np.sum(X * df["energieMetabolisable"])

        def cons_Ca_inf(X):
            return np.sum(X * df["calcium"]) - contraintes_df.loc["min", "calcium"]

        def cons_Ca_sup(X):
            return contraintes_df.loc["max", "calcium"] - np.sum(X * df["calcium"])

        def cons_P_inf(X):
            return np.sum(X * df["phosphore"]) - contraintes_df.loc["min", "phosphore"]

        def cons_P_sup(X):
            return contraintes_df.loc["max", "phosphore"] - np.sum(X * df["phosphore"])

        def cons_Lys_inf(X):
            return np.sum(X * df["lysine"]) - contraintes_df.loc["min", "lysine"]

        def cons_Lys_sup(X):
            return contraintes_df.loc["max", "lysine"] - np.sum(X * df["lysine"])

        def cons_Meth_inf(X):
            return np.sum(X * df["methionine"]) - contraintes_df.loc["min", "lysine"]

        def cons_Meth_sup(X):
            return contraintes_df.loc["max", "methionine"] - np.sum(X * df["methionine"])

        def cons_Cys_Meth_inf(X):
            return np.sum(X * df["cysteineMethionine"]) - contraintes_df.loc["min", "cysteineMethionine"]

        def cons_Cys_Meth_sup(X):
            return contraintes_df.loc["max", "cysteineMethionine"] - np.sum(X * df["cysteineMethionine"])

        def cons_Na_inf(X):
            return np.sum(X * df["sodium"]) - contraintes_df.loc["min", "sodium"]

        def cons_Na_sup(X):
            return contraintes_df.loc["max", "sodium"] - np.sum(X * df["sodium"])

        def cons_ratio_EM_Prot_inf(X):
            return np.sum(X * df["energieMetabolisable"]) - contraintes_ratio_df.loc[
                "min", "ratioEnergieProteine"] * np.sum(X * df["proteineBrute"])

        def cons_ratio_EM_Prot_sup(X):
            return contraintes_ratio_df.loc["max", "ratioEnergieProteine"] * np.sum(X * df["proteineBrute"]) - np.sum(
                X * df["energieMetabolisable"])

        def cons_ratio_Ca_Prot_inf(X):
            return np.sum(X * df["calcium"]) - contraintes_ratio_df.loc["min", "ratioCalciumPhosphore"] * np.sum(
                X * df["phosphore"])

        def cons_ratio_Ca_Prot_sup(X):
            return contraintes_ratio_df.loc["max", "ratioCalciumPhosphore"] * np.sum(X * df["phosphore"]) - np.sum(
                X * df["calcium"])

        def cons_ratio_Lys_Meth_inf(X):
            return np.sum(X * df["lysine"]) - contraintes_ratio_df.loc["min", "ratioLysineMethionine"] * np.sum(
                X * df["methionine"])

        def cons_ratio_Lys_Meth_sup(X):
            return contraintes_ratio_df.loc["max", "ratioLysineMethionine"] * np.sum(X * df["methionine"]) - np.sum(
                X * df["lysine"])

        qte_ingredients = 100

        def cons_total(X):
            return np.sum(X) - qte_ingredients  # definir la quantité totale de mélange souhaitée

        cons1 = {"type": "ineq", "fun": cons_Prot_inf}
        cons2 = {"type": "ineq", "fun": cons_Prot_sup}
        cons3 = {"type": "ineq", "fun": cons_EM_inf}
        cons4 = {"type": "ineq", "fun": cons_EM_sup}
        cons5 = {"type": "ineq", "fun": cons_ratio_EM_Prot_inf}
        cons6 = {"type": "ineq", "fun": cons_ratio_EM_Prot_sup}
        cons7 = {"type": "ineq", "fun": cons_Ca_inf}
        cons8 = {"type": "ineq", "fun": cons_Ca_sup}
        cons9 = {"type": "ineq", "fun": cons_ratio_Ca_Prot_inf}
        cons10 = {"type": "ineq", "fun": cons_ratio_Ca_Prot_sup}
        cons11 = {"type": "ineq", "fun": cons_P_inf}
        cons12 = {"type": "ineq", "fun": cons_P_sup}
        cons13 = {"type": "ineq", "fun": cons_Lys_inf}
        cons14 = {"type": "ineq", "fun": cons_Lys_sup}
        cons15 = {"type": "ineq", "fun": cons_Meth_inf}
        cons16 = {"type": "ineq", "fun": cons_Meth_sup}
        cons17 = {"type": "ineq", "fun": cons_Cys_Meth_inf}
        cons18 = {"type": "ineq", "fun": cons_Cys_Meth_sup}
        cons19 = {"type": "ineq", "fun": cons_Na_inf}
        cons20 = {"type": "ineq", "fun": cons_Na_sup}
        cons21 = {"type": "ineq", "fun": cons_ratio_Lys_Meth_inf}
        cons22 = {"type": "ineq", "fun": cons_ratio_Lys_Meth_sup}
        cons23 = {"type": "eq", "fun": cons_total}

        b = (0, None)
        bnds = [b] * n

        contraintes_list = [cons1, cons2, cons3, cons4, cons5, cons6, cons7, cons8, cons9, cons10, cons11, cons12,
                            cons13, cons14, cons15, cons16, cons17, cons18, cons19, cons20, cons21, cons22, cons23]

        # Appel de la fonction minimize pour l'optimisation
        solution = minimize(objectif, X0, bounds=bnds, constraints=contraintes_list, method='SLSQP')

        # Parcourir le vecteur de solution et mettre à zéro les quantités inférieures à 0.001 kg (1g)
        solution.x = [x if x >= 0.001 else 0 for x in solution.x]
        # Filtrer les valeurs de solution.x qui ne sont pas égales à zéro
        filtered_solution_x = [x for x in solution.x if x != 0]

        # Afficher filtered_solution_x
        print(filtered_solution_x)
        # solution.x = [i for i, x in enumerate(solution.x) if x >= 0.001]

        # Obtenir les indices des éléments de solution.x qui sont égaux à zéro
        # zero_indices = [i for i, x in enumerate(solution.x) if x == 0]

        # Filtrer les ingrédients correspondant aux indices zéro
        # filtered_ingredients = [ingredient for i, ingredient in enumerate(ingredients_df) if i not in zero_indices]

        # Recalculer le coût total
        total_cost = sum(x * p for x, p in zip(solution.x, prix))

        # Vérification de la réussite de l'optimisation
        if solution.success:
            print(f"L'optimisation a réussi. Message : {solution.message}")
            print(f"Valeur minimale de la fonction objectif : {solution.fun}")
            print(f"Point qui minimise la fonction objectif : {solution.x}")
        else:
            print(f"L'optimisation a échoué. Message : {solution.message}")
            print(f"Point qui minimise la fonction objectif : {solution.x}")
            print(f"Valeur minimale de la fonction objectif : {solution.fun}")
            quantite = pd.Series(solution.x)
            quantite.index = ingredients_df.index

            ingredients_utilises_bool = quantite > 0
            print("Quantité des ingrédients en kg pour 100 kg de mélange :")
            print(quantite[ingredients_utilises_bool])
            print()

        # Créer un dictionnaire pour stocker les informations de la solution
        solution_dict = {
            'success': bool(solution.success),  # Convertir en booléen (python natif) pour la sérialisation JSON
            'message': solution.message,
            'fun': solution.fun,
            'x': solution.x  # Convertir le tableau numpy en liste pour la sérialisation JSON
        }
        logger.info(f"optimisation : {solution_dict}")
        # Renvoyer la solution sous forme de réponse JSON
        return JsonResponse(solution_dict, safe=False)
    except Exception as e:
        logger.error(f"Une erreur s'est produite lors du calcul d'optimisation : {e}")
        raise Http404("Une erreur s'est produite lors du calcul d'optimisation.")
